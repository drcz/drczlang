{         -= lukier składniowy - smaczny i zdrowy! =-

  zamienia wszystkie wystąpienia "?" (cond) na  zagnieżdżone if'y,
  a "let" na lambdy. formalnie jest to kompilator z drcz1 do drcz0. }


(! desugar (^ (code)
   	      (if (empty? code)
	      	  ()
		  (if (@ code)
		      code
		      (if (= (. code) '?)
		      	  (cond2if (, code))
		      	  (if (= (. code) 'let)
			      (let2lambda (, code))
			      (; (desugar (. code))
			      	 (desugar (, code)))))))))


{ - kluczowe transformacje: - }

(! cond2if (^ (condlist)
   	      (if (empty? condlist)
	      	  ()
		  (if (= (.. condlist) 'T)
		      (desugar (.,. condlist))
		      (list4 'if (desugar (.. condlist))
		      	     	 (desugar (.,. condlist))
				 (cond2if (, condlist)))))))

{ tj. (? (p1 e1) ... (pn en) (T e')) -> (if p1 e1 (if ... (if pn en e') .. )). }


(! let2lambda (^ (letexp)
   	      	 (list2 (list3 '^ (unpair-a (. letexp))
		       	       	  (, letexp))
			(unpair-b (. letexp)))))

{ tj. (let ((s1 e1) ... (sn en)) e') -> ((^ (s1 ... sn) e') e1 ... en). }


{ - i ich pomocnicy: - }

(! .. (^ (e) (. (. e))))
(! ., (^ (e) (. (, e))))
(! .,. (^ (e) (. (, (. e)))))

(! list2 (^ (a b) (; a (; b ()))))
(! list3 (^ (a b c) (; a (; b (; c ())))))
(! list4 (^ (a b c d) (; a (; b (; c (; d ()))))))

(! empty? (^ (e) (= e ())))

(! mapcar (^ (p l)
       	     (if (empty? l)
	     	 ()
		 (; (p (. l)) (mapcar p (, l))))))


{ dwie śliczne odwrotności procedury pair:
  np. (unpair-a '((a b) (c d) (e f))) -> (a c e),
      (unpair-b '((a b) (c d) (e f))) -> (b d f). }

(! unpair-a (^ (ab) (mapcar (^ (x) (. x)) ab)))
(! unpair-b (^ (ab) (mapcar (^ (x) (., x)) ab)))

{ i fajno. }
