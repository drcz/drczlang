((program inputs)
 init

 (init (let D (gen ()))
       (let R inputs)
       (let C program)
       (let PR ())
       (let PD ())
       (let DRC (call step D R C PR PD))
       (return (. (. (, DRC))))) { zwraca (. R) }

 (step (if (= C ()) end step2))

 (end (return (list D R C PR PD))) { w sumie zawsze C==()... }

 (step2 (let cmd (. C))
        (let C (, C))
        (goto check-const))

 (check-const   (if (= cmd 'CONST) do-const check-proc))
 (check-proc    (if (= cmd 'PROC) do-proc check-lookup))
 (check-lookup  (if (= cmd 'LOOKUP) do-lookup check-plookup))
 (check-plookup (if (= cmd 'PLOOKUP) do-plookup check-name))
 (check-name    (if (= cmd 'NAME) do-name check-pname))
 (check-pname   (if (= cmd 'PNAME) do-pname check-forget))
 (check-forget  (if (= cmd 'FORGET) do-forget check-pforget))
 (check-pforget (if (= cmd 'PFORGET) do-pforget check-select))
 (check-select  (if (= cmd 'SELECT) do-select check-apply))
 (check-apply   (if (= cmd 'APPLY) do-apply check-cons))
 (check-cons (if (= cmd 'CONS) do-cons check-car))
 (check-car  (if (= cmd 'CAR) do-car check-cdr))
 (check-cdr  (if (= cmd 'CDR) do-cdr check-eq))
 (check-eq   (if (= cmd 'EQ) do-eq check-num))
 (check-num  (if (= cmd 'NUM) do-num check-atom))
 (check-atom (if (= cmd 'ATOM) do-atom check-add))
 (check-add  (if (= cmd 'ADD) do-add check-sub))
 (check-sub  (if (= cmd 'SUB) do-sub check-mul))
 (check-mul  (if (= cmd 'MUL) do-mul check-div))
 (check-div  (if (= cmd 'DIV) do-div check-mod))
 (check-mod  (if (= cmd 'MOD) do-mod check-gt))
 (check-gt   (if (= cmd 'GT) do-gt check-lt))
 (check-lt   (if (= cmd 'LT) do-lt err))

 (err (return (list 'ERROR 'UNKNOWN 'COMMAND cmd)))

 (do-const (let exp (. C))
           (let C (, C))
           (let R (; exp R))
           (goto step))

 (do-proc (let proc (. C))
          (let C (, C))
          (let PR (; proc PR)) {!}
          (goto step))

 (do-lookup (let var (. C))
            (let C (, C))
            (let R (; (. (AL:lookup var D)) R))
            (goto step))

 (do-name (let var (. C))
          (let val (. R))
          (let C (, C))
          (let R (, R))
          (let D (AL:update var (; val (AL:lookup var D)) D))
          (goto step))

 (do-forget (let var (. C))
            (let C (, C))
	    (let D (AL:update var (, (AL:lookup var D)) D))
            (goto step))

 (do-plookup (let var (. C))
             (let C (, C))
             (let PR (; (. (AL:lookup var PD)) PR))
             (goto step))

 (do-pname (let var (. C))
           (let proc (. PR))
           (let C (, C))
           (let PR (, PR)) {!}
           (let PD (AL:update var (; proc (AL:lookup var PD)) PD))
           (goto step))

 (do-pforget (let var (. C))
             (let C (, C))
	     (let PD (; (AL:update var (, (AL:lookup var PD)) PD) ()))
             (goto step))

 (do-select (let perm (. R))
            (let R (, R))
            (let concl (. C))
            (let alt (. (, C)))
            (let C (, (, C)))
            (if perm do-concl do-alt))

 (do-concl (let C (append concl C))
           (goto step))

 (do-alt (let C (append alt C))
         (goto step))

 (do-apply (let proc (. PR))
           (let PR (, PR))
           (let oC C)
	   (let C proc)
           (let DRC (call step D R C PR PD))
           (let D (. DRC))
           (let R (. (, DRC)))
           (let PR (. (, (, DRC))))
           (let PD (. (, (, (, DRC)))))
           (let C oC)
           (goto step))

 (do-cons (let arg1 (. R))
          (let arg2 (. (, R)))
          (let R (, (, R)))
          (let res (; arg1 arg2))
          (let R (; res R))
          (goto step))

 (do-car (let arg1 (. R))
         (let R (, R))
         (let res (. arg1))
         (let R (; res R))
         (goto step))

 (do-cdr (let arg1 (. R))
         (let R (, R))
         (let res (, arg1))
         (let R (; res R))
         (goto step))

 (do-eq (let arg1 (. R))
        (let arg2 (. (, R)))
        (let R (, (, R)))
        (let res (= arg1 arg2))
        (let R (; res R))
        (goto step))

 (do-num (let arg1 (. R))
         (let R (, R))
         (let res (# arg1))
         (let R (; res R))
         (goto step))

 (do-atom (let arg1 (. R))
          (let R (, R))
          (let res (@ arg1))
          (let R (; res R))
          (goto step))

 (do-add (let arg1 (. R))
         (let arg2 (. (, R)))
         (let R (, (, R)))
         (let res (+ arg1 arg2))
         (let R (; res R))
         (goto step))

 (do-sub (let arg1 (. R))
         (let arg2 (. (, R)))
         (let R (, (, R)))
         (let res (- arg1 arg2))
         (let R (; res R))
         (goto step))

 (do-mul (let arg1 (. R))
         (let arg2 (. (, R)))
         (let R (, (, R)))
         (let res (* arg1 arg2))
         (let R (; res R))
         (goto step))

 (do-div (let arg1 (. R))
         (let arg2 (. (, R)))
         (let R (, (, R)))
         (let res (/ arg1 arg2))
         (let R (; res R))
         (goto step))

 (do-mod (let arg1 (. R))
         (let arg2 (. (, R)))
         (let R (, (, R)))
         (let res (% arg1 arg2))
         (let R (; res R))
         (goto step))

 (do-gt (let arg1 (. R))
        (let arg2 (. (, R)))
        (let R (, (, R)))
        (let res (> arg1 arg2))
        (let R (; res R))
        (goto step))

 (do-lt (let arg1 (. R))
        (let arg2 (. (, R)))
        (let R (, (, R)))
        (let res (< arg1 arg2))
        (let R (; res R))
        (goto step))
)