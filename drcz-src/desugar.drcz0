{         -= lukier składniowy - smaczny i zdrowy! =-

  zamienia wszystkie wystąpienia "?" (cond) na  zagnieżdżone if'y,
  a "let" na lambdy. formalnie jest to kompilator z drcz1 do drcz0. }


(! desugar (^ (code)
   	      (if (empty? code)
	      	  ()
		  (if (@ code)
		      code
		      (if (= (. code) '?)
		      	  (cond2if (, code))
		      	  (if (= (. code) 'let)
			      (let2lambda (, code))
			      (; (desugar (. code))
			      	 (desugar (, code)))))))))


{ - kluczowe transformacje: - }

(! cond2if (^ (condlist)
   	      (if (empty? condlist)
	      	  ()
		  (if (= (.. condlist) 'T)
		      (desugar (.,. condlist))
		      (list4 'if (desugar (.. condlist))
		      	     	 (desugar (.,. condlist))
				 (cond2if (, condlist)))))))

{ tj. (? (p1 e1) ... (pn en) (T e')) -> (if p1 e1 (if ... (if pn en e') .. )). }


(! let2lambda (^ (letexp)
   	      	 (list2 (list3 '^ (unpair-l (. letexp))
		       	       	  (, letexp))
			(unpair-r (. letexp)))))

{ tj. (let ((s1 e1) ... (sn en)) e') -> ((^ (s1 ... sn) e') e1 ... en). }


{ - i ich pomocnicy: - }

(! .. (^ (e) (. (. e))))
(! ., (^ (e) (. (, e))))
(! .,. (^ (e) (. (, (. e)))))

(! list2 (^ (a b) (; a (; b ()))))
(! list3 (^ (a b c) (; a (; b (; c ())))))
(! list4 (^ (a b c d) (; a (; b (; c (; d ()))))))

(! empty? (^ (e) (= e ())))

(! mapcar (^ (p l)
       	     (if (empty? l)
	     	 ()
		 (; (p (. l)) (mapcar p (, l))))))


{ takie tu ten... może raczej nazwać by to 'extract'?
  ale to teraz i tak bez znaczenia, bo w zasadzie byłoby lepiej w miejscu wywołania
  nazwać je podług czynności które wykonują, np extract-symbols i extract-vals...

  np. (unpair-l '((a1 b1) (a2 b2) (a3 b3))) -> (a1 a2 a3),
      (unpair-r '((a1 b1) (a2 b2) (a3 b3))) -> (b1 b2 b3). }

(! unpair-l (^ (ab) (mapcar (^ (x) (. x)) ab)))
(! unpair-r (^ (ab) (mapcar (^ (x) (., x)) ab)))

{ i fajno. }
